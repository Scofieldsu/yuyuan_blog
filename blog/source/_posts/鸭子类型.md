---
title: 鸭子类型
date: 2015-04-28 20:19:42
categories: python
comment: false 
tags: python
---

#鸭子类型（duck typing）

在程序设计中，鸭子类型是动态类型的一种风格。

在这种风格中，一个对象有效的语义， 不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。

这个概念的名字来源于由James Whitcomb Riley提出的鸭子测试，“鸭子测试”可以这样表述：

当看到一只鸟走起来像鸭子、游泳像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。

在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。

例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭子的对象，并调用它的走和叫的方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将会引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。

-------------------
<!-- more -->

鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。

从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性（Python文档中有一句：鸭子类型应避免使用type()或instance()等方法来测试类型是否合法）

看下面一段代码：
'
- # I love you
- class Duck:
- def quack(self):
- print('呱呱呱！')
- def feathers(self):
- print('这个鸭子拥有灰白的羽毛')
- class Person:
- def quack(self):
- print('我不是鸭子')
- def feathers(self):
- print('这个人穿着一件鸭绒大衣')
- def in_the_forest(duck):
- duck.quack()
- duck.feathers()
- def game():
- donald = Duck()
- john = Person()
- in_the_forest(donald)
- in_the_forest(john)
- game()
'
- #返回：
- #呱呱呱！
- #这个鸭子拥有灰白的羽毛
- #我不是鸭子
- #这个人穿着一件鸭绒大衣
从哪里可以看出Python是鸭子类型的风格呢？

in_the_forest()函数对参数duck只有一个要求：就是可以实现quack()和feathers()方法。然而Duck类和Person类都实现了quack()和feathers()方法，因此它们的实例对象donald和john都可以用作in_the_forest()的参数。这就是鸭子类型。

如果不是鸭子类型的做法

- def in_the_forest(animal):
- animal.quack()
- animal.feathers()

class animal:
      def quack():
             pass
       def  feathers():
            pass

- class Duck(animal):
- def quack(self):
- print('呱呱呱！')
- def feathers(self):
- print('这个鸭子拥有灰白的羽毛')

- class Person(animal):
- def quack(self):
- print('我不是鸭子')
- def feathers(self):
- print('这个人穿着一件鸭绒大衣')

- def game():
- donald = Duck()
- john = Person()
- in_the_forest(donald)
- in_the_forest(john)

- game()
